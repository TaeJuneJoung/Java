# Chater8

## 내부 클래스란?

클래스 내부에 구현한 클래스(중첩된 클래스)

클래스 내부에서 사용하기 위해 선언하고 구현하는 클래스

주로 외부 클래스 생성자에서 내부 클래스를 생성



### 내부 클래스 유형

| 종류                 | 구현 위치                                         | 사용할 수 있는 외부 클래스 변수        | 생성 방법                                                    |
| -------------------- | ------------------------------------------------- | -------------------------------------- | ------------------------------------------------------------ |
| 인스턴스 내부 클래스 | 외부 클래스 멤버 변수와 동일                      | 외부 인스턴스 변수<br />외부 전역 변수 | 외부 클래스를 먼저 만든 후<br />내부 클래스 생성             |
| 정적 내부 클래스     | 외부 클래스 멤버 변수와 동일                      | 외부 전역 변수                         | 외부 클래스와 무관하게 생성                                  |
| 지역 내부 클래스     | 메서드 내부에 구현                                | 외부 인스턴스 변수<br />외부 전역 변수 | 메서드를 호출할 때 생성                                      |
| 익명 내부 클래스     | 메서드 내부에 구현<br />변수에 대입하여 직접 구현 | 외부 인스턴스 변수<br />외부 전역 변수 | 메서드를 호출할 때 생성되거나,<br />인터페이스 타입 변수에 대입할 때 new 예약어를 사용하여 생성 |

익명 내부 클래스를 안드로이드 프로그래밍에서 자주 사용함



## 람다식이란?

자바에서 함수형 프로그래밍(functional programming)을 구현하는 방식

클래스를 생성하지 않고 함수의 호출만으로 기능을 수행

함수형 인터페이스를 선언함

자바 8부터 지원



### 함수형 프로그래밍이란?

순수 함수(pure function)를 구현하고 호출

매개 변수만을 사용하도록 만든 함수로 외부 자료에 부수적인 영향(side effect)가 발생하지 않도록함

입력 받은 자료를 기반으로 수행되고 외부에 영향을 미치지 않으므로 병렬처리 등에 가능한 안정적인 확장성 있는 프로그래밍 방식



### 람다식 문법

매개 변수 하나인 경우 괄호 생략가능(두 개인 경우는 괄호를 생략할 수 없음)

```java
str -> {System.out.println(str);}
```

중괄호 안의 구현부가 한 문장인 경우 중괄호 생략가능

```java
str -> System.out.println(str);
```

중괄호 안의 구현부가 한 문장이라도 return이 있다면 중괄호를 생략할 수 없다

```java
//str -> return str.length(); //오류 발생
```

중괄호 안의 구현부가 반환문 하나라면 return과 중괄호를 모두 생략할 수 있다

```java
(x, y) -> x+y; //두 값을 더하여 반환
str -> str.length(); //문자열 길이를 반환
```





`@FunctionalInterface` -> 함수형 인터페이스라는 것을 알려줌(람다식을 위한 인터페이스)

2개의 함수를 사용할 수 없다. -> 어떠한 함수를 사용해야할지 모르기에



### 함수를 변수처럼 사용하는 람다식

프로그램에서 변수는 ...

```
자료형에 기반하여 선언하고 int a;
매개변수로 전달하고 int add(int x, int y);
메서드의 반환 값으로 사용 return num;
```

람다식은 프로그램 내에서 변수처럼 사용할 수 있다.

## 스트림(Stream)

Java I/O에서 말하는 Stream과는 다른 Stream을 다뤄보자.

**자료의 연산을 수행하는 Stream**

자료의 대상과 관계없이 동일한 연산을 수행할 수 있는 기능(자료의 추상화)

배열, 컬렉션에 동일한 연산이 수행되어 일관성 있는 처리 가능

한번 생성하고 사용한 스트림은 재사용할 수 없다

스트림 연산은 기존 자료를 변경하지 않는다

중간 연산과 최종 연산으로 구분 된다

최종 연산이 수행되어야 모든 연산이 적용되는 지연 연산



### 스트림 연산 - 중간 연산

중간 연산 - filter(), map()

조건에 맞는 요소를 추출(filter()) 하거나 요소를 변환함(map())

문자열의 길이가 5이상인 요소만 출력하기

```java
sList.stream().filter(s -> s.length() >= 5).forEach(s -> System.out.println(s));
```

1. 스트림 생성

```java
sList.stream()
```

2. 중간 연산

```java
sList.stream().filter(s -> s.length() >= 5)
```

3. 최종 연산

```java
sList.stream().filter(s -> s.length() >= 5).forEach(s -> System.out.println(s));
```

고객 클래스에서 고객 이름만 가져오기

```java
customerList.stream().map(c -> c.getName()).forEach(s -> System.out.println(s));
```



### 스트림 연산 - 최종 연산

스트림의 자료를 소모하면서 연산을 수행

최종 연산 후에 스트림은 더 이상 다른 연산을 적용할 수 없음

- forEach() : 요소를 하나씩 꺼내 옴
- count() : 요소의 개수
- sum() : 요소의 합

이 외도 여러가지 최종연산이 있다



#### reduce() 연산

정의된 연산이 아닌 프로그래머가 직접 지정하는 연산을 적용

최종 연산으로 스트림의 요소를 소모하며 연산 수행



배열의 모든 요소의 합을 구하는 reduce()연산

```java
Arrays.stream(arr).reduce(0, (a,b) -> a+b);
```

`0` : 초기값

`(a, b)` : 전달되는 요소

`-> (a + b)` : 각 요소가 수행해야 할 기능


